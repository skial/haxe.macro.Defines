package ;

import sys.Http;
import haxe.Json;
import haxe.Timer;
import sys.io.File;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Printer;

using StringTools;
using haxe.io.Path;
using sys.FileSystem;

typedef TDefine = {
    name:String,
    define:String,
    doc:String,
    ?platforms:Array<String>,
    ?links:Array<String>,
    ?params:Array<String>,
    ?devcomment:String,
}

class Entry {

    public static final printer:Printer = new Printer();

    public static var DefinesJson:String =
    if (Context.defined('defines.json')) {
        var value = Context.definedValue('defines.json').normalize();

        if (!value.isAbsolute()) {
            value = FileSystem.fullPath(Context.resolvePath(value));
        }

        value;

    } else {
        // TODO: Really needs to be `https` but eval doesnt support ssl connections.
        'https://raw.githubusercontent.com/HaxeFoundation/haxe/development/src-json/define.json';

    }
    public static final cwd:String = Sys.getCwd();
    public static final DefinesLocal:String = '$cwd/cached/'.normalize();

    public static var outputPath = '$cwd/src/haxe/macro/Defines.hx';

    public static function main() {
        // TODO: Should be `https`.
        var isHttps = DefinesJson.startsWith('https:');

        if (isHttps && FileSystem.exists(DefinesLocal + 'define.json')) {
            DefinesJson = DefinesLocal + 'define.json';
            isHttps = false;
        }

        var wait = true;
        var content = '';

        if (isHttps) {
            // TODO: Once eval supports https connections, drop tink_* libs.
            //Http.requestUrl(DefinesJson);

            tink.http.Client.fetch(DefinesJson, {client:Curl}).all().handle( o -> switch o {
                case Success(response):
                    wait = false;
                    content = response.body.toString();

                case Failure(e):
                    wait = false;
                    Context.fatalError('HTTPS error: $e', Context.currentPos());

            } );

        } else {
            wait = false;
            content = File.getContent(DefinesJson);

        }

        var timestamp = Timer.stamp();
        while (wait) {
            if ((Timer.stamp() - timestamp) > 4) {
                Context.fatalError('Failed to load `defines.json` via https request.', Context.currentPos());
                break;
            }
        }
        
        //trace( content );

        var json:Array<TDefine> = Json.parse( content );
        var extra:Array<TDefine> = Json.parse( File.getContent('./build/extra.json') );

        json = json.concat( extra );

        if (isHttps) {
            if (!DefinesLocal.exists()) DefinesLocal.createDirectory();
            File.saveContent( DefinesLocal + '/define.json', content );

        }

        var pos = Context.currentPos();
        var fields = [];
        for (define in json) {
            //trace( define );
            var name = define.name;
            var expr = {expr:EConst(CString(define.define)), pos:pos};
            var field = (macro class {
                public var $name = $expr;
            }).fields[0];
            field.doc = 'Usage: `-D ${define.define}`\n- - -\n${define.doc}\n';
            if (define.devcomment != null) field.doc += '- - -\n${define.devcomment}\n';
            if (define.params != null) field.doc += '- - -\nAccepts parameters: ${define.params.join('|')}\n';
            if (define.platforms != null) field.doc += '- - -\nPlatform${define.platforms.length == 0 ? 's' :''}: ${define.platforms.join('|')}\n';
            if (define.links != null) field.doc += '- - -\n@see: ${define.links.join('|')}\n';

            //trace( printer.printField( field ) );
            //break;
            fields.push( field );

        }

        var td:TypeDefinition = macro class {
            public inline function get():String {
                return haxe.macro.Context.definedValue(this);
            }

            @:to public inline function asBool():Bool {
                return haxe.macro.Context.defined(this);
            }

            @:op(A == B) @:commutative private static inline function equals(a:Defines, b:Bool) {
                return a.asBool() == b;
            }

            @:op(!A) private static inline function negate(a:Defines) {
                return !a.asBool();
            }

            @:op(A != B) @:commutative private static inline function not(a:Defines, b:Bool) {
                return a.asBool() != b;
            }

            @:op(A && B) @:commutative private static inline function and(a:Defines, b:Bool) {
                return a.asBool() && b;
            }
        }
        td.doc = 'Do not edit this file is auto-generated.\nBuilt off `define.json` found at https://raw.githubusercontent.com/HaxeFoundation/haxe/development/src-json/define.json';
        td.pack = ['haxe', 'macro'];
        td.name = 'Defines';
        td.kind = TDAbstract(macro:String, [macro:String], [macro:String]);
        td.meta = [
            {name:':enum', params:[], pos:td.pos}, 
            {name:':forward', params:[], pos:td.pos}, 
            {name:':forwardStatics', params:[], pos:td.pos}
        ];
        td.fields = fields.concat(td.fields);

        if (!outputPath.directory().exists()) outputPath.directory().createDirectory();
        File.saveContent(outputPath, printer.printTypeDefinition(td, true));
    }

}